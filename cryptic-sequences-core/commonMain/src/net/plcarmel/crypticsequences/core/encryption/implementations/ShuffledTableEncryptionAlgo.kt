package net.plcarmel.crypticsequences.core.encryption.implementations

import net.plcarmel.crypticsequences.core.encryption.definitions.NumberBasedEncryptionAlgo
import net.plcarmel.crypticsequences.core.numbers.BaseSystem
import kotlin.math.ln
import kotlin.math.roundToInt
import kotlin.random.Random

/**
 * Encryption algo that encrypts words of a given number of digits using a table generated by a provided random number
 * generator.
 *
 * @param baseSystem
 *  the size of individual digits
 *  It has an impact on the size of the generate table.
 *
 * @param wordSize
 *  the number of digits that this algo encrypts at a time
 *  This will impact the size of the generated table and should be kept small. However, it should vary with
 *  the base, because using a small number of digits with a small base will result in an extremely small effective
 *  key size.
 */
class ShuffledTableEncryptionAlgo(
  override val baseSystem: BaseSystem,
  val prng: Random,
  override val wordSize: Int = (ln(256.0) / ln(baseSystem.base.toDouble())).roundToInt().coerceAtLeast(2)
) : NumberBasedEncryptionAlgo {

  private val n = baseSystem.nbValues(wordSize).toInt()

  private val mainTable: IntArray = createTable(n, prng)

  private fun deriveTable(smallerWordSize: Int): IntArray =
    Companion.deriveTable(mainTable, baseSystem.nbValues(smallerWordSize).toInt())

  private val allTables: Map<Int, IntArray> =
    ((1 until wordSize).map { it to deriveTable(it) } + listOf(wordSize to mainTable)).toMap()

  override fun encrypt(word: ByteArray, at: Int) {
    val nbDigits = word.size.coerceAtMost(wordSize)
    val table = allTables[nbDigits]!!
    baseSystem
      .combineDigitsFrom(word, at, nbDigits)
      .toInt()
      .let(table::get)
      .toLong()
      .let { baseSystem.extractDigitsAt(word, it, at, nbDigits) }
  }

  companion object {

    private fun createTableFromCycle(cycle: List<Int>): IntArray {
      val n = cycle.size
      val table = IntArray(n)
      for (i in 0 until n-1) {
        table[cycle[i]] = cycle[i+1]
      }
      if (n != 0) {
        table[cycle[n-1]] = cycle[0]
      }
      return table
    }

    fun createTable(n: Int, prng: Random): IntArray =
      createTableFromCycle((0 until n).shuffled(prng)) // Fisher-Yates shuffle

    private fun deriveTable(mainTable: IntArray, n: Int): IntArray =
      mainTable
        .take(n)
        .let(Companion::getOrder)
        .toIntArray()

    private fun getOrder(numbers: List<Int>): List<Int> =
      numbers
        .indices
        .map { Pair(it, numbers[it]) }
        .sortedBy { (_, n) -> n }
        .map { (i, _) -> i }

  }
}
