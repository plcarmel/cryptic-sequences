package net.plcarmel.encryptedsequences.core.encryption.implementations

import net.plcarmel.encryptedsequences.core.encryption.definitions.FixedSizeWordEncryptionAlgo
import net.plcarmel.encryptedsequences.core.numbers.BaseSystem
import net.plcarmel.encryptedsequences.core.numbers.BaseSystem.Companion.zeroPad
import java.util.*

/**
 * Encryption algo that encrypts words of a given number of digits using a table generated by the Random number
 * generator of Java. Note that the implementation of the random number generator is the same among all versions of
 * the JVM, so no worries there.
 *
 * Note: Please do NOT use this to encrypt sensitive data as this is not a real vetted encryption algorithm and the
 * key size is too small anyway. It is just meant to obfuscate information to make it look more random to users.
 *
 * @param baseSystem
 *  the size of individual digits
 *  It has an impact on the size of the generate table.
 *
 * @param wordSize
 *  the number of digits that this algo encrypts at a time
 *  This will impact the size of the generate table and should be kept small.
 */
class ShuffledTableEncryptionAlgo(
  override val baseSystem: BaseSystem,
  @Suppress("MemberVisibilityCanBePrivate") val key: Long, // 48 bits
  override val wordSize: Int = 2
) : FixedSizeWordEncryptionAlgo {

  private val rnd = Random(key)
  private val n = baseSystem.nbValues(wordSize)

  private val mainTable: LongArray = (0 until n).shuffled(rnd).toLongArray()

  private fun deriveTable(smallerWordSize: Int): LongArray =
    mainTable
      .take(baseSystem.nbValues(smallerWordSize).toInt())
      .let(Companion::getOrder)
      .toLongArray()

  private val allTables: Map<Int, LongArray> =
    ((1 until wordSize).map { it to deriveTable(it) } + listOf(wordSize to mainTable)).toMap()

  override fun encrypt(word: IntArray, at: Int) {
    val nbDigits = word.size.coerceAtMost(wordSize)
    val table = allTables[nbDigits]!!
    val zeroPad = { digits: IntArray -> zeroPad(nbDigits, digits) }
    val copyToArray = { src: IntArray -> copyToArrayAt(word, at, src) }
    subArray(word, at, nbDigits)
      .let(baseSystem::combineDigits)
      .let(Long::toInt)
      .let(table::get)
      .let(baseSystem::extractDigits)
      .let(zeroPad)
      .let(copyToArray)
  }

  companion object {

    private fun getOrder(numbers: List<Long>): List<Long> =
      numbers
        .indices
        .map { Pair(it.toLong(), numbers[it]) }
        .sortedBy { (_, n) -> n }
        .map { (i, _) -> i }

  }
}
