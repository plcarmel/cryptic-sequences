package org.example.encryption.implementations

import org.example.encryption.definitions.FixedSizeWordEncryptionAlgo
import org.example.numbers.BaseSystem
import org.example.numbers.BaseSystem.Companion.zeroPad
import java.util.*
import kotlin.math.pow

/**
 * Encryption algo that encrypts words of a given number of digits using a table generated by the Random number
 * generator of Java. Note that the implementation of the random number generator is the same among all versions of
 * the JVM, so no worries there.
 *
 * Note: Please do NOT use this to encrypt sensitive data as this is not a real vetted encryption algorithm and the
 * key size is too small anyway. It is just meant to obfuscate information to make it look more random to users.
 *
 * @param baseSystem
 *  the size of individual digits
 *  It has an impact on the size of the generate table.
 *
 * @param wordSize
 *  the number of digits that this algo encrypts at a time
 *  This will impact the size of the generate table and should be kept small.
 */
class ShuffledTableEncryptionAlgo(
  private val baseSystem: BaseSystem,
  @Suppress("MemberVisibilityCanBePrivate") val key: Long, // 48 bits
  override val wordSize: Int = 2
) : FixedSizeWordEncryptionAlgo {

  override val base: Int
    get() = baseSystem.base

  private val rnd = Random(key)
  private val n = base.toDouble().pow(wordSize).toInt()

  private val mainTable: IntArray = (0 until n).shuffled(rnd).toIntArray()

  private fun deriveTable(nbDigits: Int): IntArray =
    mainTable
      .take(base.toDouble().pow(nbDigits).toInt())
      .let(Companion::getOrder)
      .toIntArray()

  private val allTables: Map<Int, IntArray> =
    ((1 until wordSize).map { it to deriveTable(it) } + listOf(wordSize to mainTable)).toMap()

  override fun encrypt(word: IntArray, at: Int) {
    val nbDigits = word.size.coerceAtMost(wordSize)
    val table = allTables[nbDigits]!!
    val zeroPad = { digits: IntArray -> zeroPad(nbDigits, digits) }
    val copyToArray = { src: IntArray -> copyToArrayAt(word, at, src) }
    subArray(word, at, nbDigits)
      .let(baseSystem::combineDigits)
      .let(table::get)
      .let(baseSystem::extractDigits)
      .let(zeroPad)
      .let(copyToArray)
  }

  companion object {

    private fun getOrder(numbers: List<Int>): List<Int> =
      numbers
        .indices
        .map { Pair(it, numbers[it]) }
        .sortedBy { (_, n) -> n }
        .map { (i, _) -> i }

  }
}
